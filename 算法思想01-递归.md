[toc]
# 1.算法思想01-递归

## 1.1 递归函数

> 递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调用

如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会**将给定的问题拆解为子问题**。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。

为了确保递归函数不会导致无限循环，它应具有以下属性：

1. 一个简单的<mark>`基本情况（basic case）`</mark>（或一些案例） —— 能够不使用递归来产生答案的终止方案。
2. 一组规则，也称作<mark>`递推关系（recurrence relation）`</mark>，可将所有其他情况拆分到基本案例。

注意，函数可能会有多个位置进行自我调用。

**递归小结**

* 递归指的是调用自己的函数
* 每个递归函数都有两个条件：基线条件和递归条件。
* 所有函数调用都进入调用栈

* 调用栈可能很长，这将占用大量的内存 

## 1.2 递归经典案例实战

### 1.2.1 汉诺塔问题

大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。要求如下

1.  大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。
2. 在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。

结题思路：

在有n个盘子时

1. 把n-1个圆盘从A经过C移动到B
2. 把第n个圆盘从A移动到C
3. 把n-1个小圆盘从B经过A移动到C
<img src="https://typora-1259305686.cos.ap-guangzhou.myqcloud.com/uPic/image-20231114172608897.png" alt="image-20231114172608897" style="zoom:25%;" />

按照上述的描述方式，可以列出递推式如下

```
h(x) = h(x-1) + 1 + h(x-1)
```

而h(64)=18446744073709551615

假设婆罗门每秒钟搬一个盘子，则总共需要5800亿年！

样例代码如下

```python
def hanoi(n, a, b, c):
    if n > 0:
        hanoi(n - 1, a, c, b)
        print(f"moving from {a} to {c}")
        hanoi(n - 1, b, a, c)


if __name__ == '__main__':
    hanoi(3, "A", "B", "C")
```



### 1.2.2 斐波那契数列问题





































